/* 1 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000200"),
	"description" : "PDF",
	"name" : "Render PDF",
	"script" : "var Mustache = require(\"mustache\");\r\nvar pdf = require(\"html-pdf\");\r\nvar moment = require(\"moment-timezone\");\r\n\r\n(async function() {\r\n  // form values\r\n  let data = Object.assign({}, req.query, req.body);\r\n\r\n  // load from the database\r\n  await res.locals.ds.connect();\r\n  data = await res.locals.ds.find(data.collection, {\r\n    _id: ObjectID(data._id)\r\n  });\r\n\r\n  // take the first row\r\n  data = data[0]\r\n\r\n  // transform\r\n  eval(res.locals.configuration.transform)\r\n\r\n  // prepare html\r\n  var html = Mustache.render(res.locals.configuration.template, data);\r\n\r\n  // convert html to pdf\r\n  await new Promise(function(resolve, reject) {\r\n    pdf\r\n      .create(html, res.locals.configuration.options)\r\n      .toBuffer(function(err, buffer) {\r\n        res.setHeader(\r\n          \"Content-disposition\",\r\n          `inline; filename=${new Date().getTime()}.pdf`\r\n        );\r\n        res.end(buffer, \"binary\");\r\n        resolve(true);\r\n      });\r\n  });\r\n\r\n})();\r\n"
},

/* 2 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000190"),
	"description" : "REST",
	"name" : "Call External REST",
	"script" : "var rp = require('request-promise-native');\r\n\r\nasync function run() {\r\n    \r\n    // read configuration\r\n    let config = res.locals.configuration\r\n    if (!config) return \"No Configuration Specified\"\r\n    \r\n    // form values\r\n    let data = Object.assign({}, req.query, req.body)\r\n    \r\n    // do something        \r\n    if(config.beforeSending) eval(config.beforeSending)\r\n    let options = eval(config.options)        \r\n    let response = await rp(options)\r\n    if(config.afterSending) eval(config.afterSending)\r\n    \r\n    return response\r\n}\r\n\r\nrun()\r\n"
},

/* 3 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000180"),
	"description" : "Send Email",
	"name" : "Send Email",
	"script" : "var nodemailer = require('nodemailer');\n\nasync function run() {\n\n    // get navigation_id\n    let navigation_id = req.headers['x-app-key']\n    if (!navigation_id) return \"No X-App-Key specified\"\n\n    // form values\n    let data = Object.assign({}, req.query, req.body)\n\n    // retrieve data service\n    let ds = res.locals.ds\n    if (!ds) return { error: 'No data service instantiated' }\n\n    // connect to database\n    await ds.connect()\n\n    // get email configuration\n    let config = await ds.find('core.config', { _id: ObjectID(navigation_id) })\n    if (config.length == 0) return { error: \"Config doesn't exist\" }\n    config = config[0]\n\n    //\n    let user = config.smtp_user_name\n    if (!user) return { error: \"Username not specified\" }\n\n    let pass = req.app.locals.encryption.decrypt(config.smtp_password)\n    if (!pass) return { error: \"Password not specified\" }\n\n    // prepare server\n    let transporter = nodemailer.createTransport({\n        service: 'gmail',\n        auth: { user: user, pass: pass }\n    });\n\n    // prepare email context\n    var mailOptions = {\n        from: user,\n        to: data.to ? data.to.join() : '',\n        subject: data.title,\n        html: data.body\n    }\n\n    // see if there is a template\n    if (data.trigger && config.notification_templates) {\n        let template = config.notification_templates.find(x => x.trigger == data.trigger)\n        if (template) {\n            if (template.to) mailOptions.to = eval(template.to)\n            if (template.title) mailOptions.subject = eval(template.title)\n            if (template.body) mailOptions.html = eval(template.body)\n        }\n    }\n\n    // send email\n    if (mailOptions.to) return await sendemail(transporter, mailOptions)\n}\n\nasync function sendemail(transporter, mailOptions) {\n    return new Promise(function (resolve, reject) {\n        transporter.sendMail(mailOptions,\n            (error, info) => {\n                if (error) reject(error)\n                resolve(info)\n            })\n    })\n}\n\nrun()\n"
},

/* 4 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000170"),
	"description" : "Dropbox Download",
	"name" : "Dropbox Download",
	"script" : "async function run() {\n\n    // get navigation id\n    let navigation_id = req.cookies['x-app-key']\n    if (!navigation_id) navigation_id = req.query.navigation_id\n    if (!navigation_id) return \"No X-App-Key specified\"\n\n    // retrieve data service\n    let ds = res.locals.ds\n    if (!ds) return \"No data service instantiated\"\n    // connect to database\n    await ds.connect()\n\n    // get dropbox token\n    let config = await ds.find('core.config', { _id: ObjectID(navigation_id) })\n    if (config.length == 0) return { error: \"Config doesn't exist\" }\n    config = config[0]\n    let dropbox_api_key = req.app.locals.encryption.decrypt(config.dropbox_api_key)\n    if (!dropbox_api_key) return { error: 'dropbox api key is required' }\n\n    // form values\n    let data = Object.assign({}, req.query, req.body)\n    // get uploaded filestream\n    let file = await download(dropbox_api_key, data.filepath)\n\n    // respond with file\n    res.setHeader('Content-disposition', `inline; filename=${file.name}`);\n    res.end(file.fileBinary, 'binary')\n\n    return\n}\n\nvar fetch = require('isomorphic-fetch'); // or another library of choice.\nvar Dropbox = require('dropbox').Dropbox;\n//\nasync function download(dropbox_api_key, filepath) {\n    return new Promise(function (resolve, reject) {\n        var dbx = new Dropbox({ accessToken: dropbox_api_key, fetch: fetch });\n        dbx.filesDownload({ path: filepath })\n            .then(function (file, error) {\n                if(error) reject(error)\n                resolve(file)\n            })\n            .catch(function (err) {\n                reject(err)\n            });\n    })\n}\n\nrun()\n"
},

/* 5 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000160"),
	"description" : "Dropbox Upload",
	"name" : "Dropbox Upload",
	"script" : "async function run() {\n\n    // get navigation id\n    let navigation_id = req.headers['x-app-key']\n    if (!navigation_id) return \"No X-App-Key specified\"\n\n    // retrieve data service\n    let ds = res.locals.ds\n    if (!ds) return \"No data service instantiated\"\n    // connect to database\n    await ds.connect()\n\n    // get dropbox token\n    let config = await ds.find('core.config', { _id: ObjectID(navigation_id) })\n    if (config.length == 0) return { error: \"Config doesn't exist\" }\n    config = config[0]\n    let dropbox_api_key = req.app.locals.encryption.decrypt(config.dropbox_api_key)\n    if (!dropbox_api_key) return { error: 'dropbox api key is required' }\n\n    // folder path\n    let folderpath = req.query.folder\n    if (!folderpath) return { error: 'no folder path specified' }\n\n    // get uploaded filestream\n    let file = await fileContent()\n\n    // upload to dropbox\n    let saveTo = `/${folderpath}/${file.filename}`\n    let result = await upload(dropbox_api_key, saveTo, file.contents)\n    return [result]\n}\n\nasync function fileContent() {\n\n    return new Promise(function (resolve, reject) {\n        let _filename\n        var MemoryStream = require('memorystream');\n        var memStream = new MemoryStream(null, { readable: false });\n\n        req.busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {\n            // save filename\n            _filename = filename\n\n            // write to the memory buffer\n            file.pipe(memStream)\n\n        });\n\n        req.busboy.on('finish', function () {\n            resolve({\n                filename: _filename,\n                contents: Buffer.concat(memStream.queue)\n            })\n        });\n\n        req.pipe(req.busboy);\n    })\n}\n\nvar fetch = require('isomorphic-fetch'); // or another library of choice.\nvar Dropbox = require('dropbox').Dropbox;\nasync function upload(dropbox_api_key, saveTo, contents) {\n    return new Promise(function (resolve, reject) {\n        var dbx = new Dropbox({ accessToken: dropbox_api_key, fetch: fetch });\n\n        dbx.filesUpload({ path: saveTo, contents: contents })\n            .then(function (response) {\n                resolve(saveTo);\n            })\n            .catch(function (err) {\n                res.status(500)\n                res.send(err)\n                reject(JSON.stringify(err));\n            });\n    })\n}\n\nrun()\n"
},

/* 6 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000030"),
	"description" : "Delete an item",
	"name" : "MongoDB Delete",
	"script" : "async function run() {\r\n    // read configuration\r\n    let config = res.locals.configuration\r\n    if (!config) return \"No Configuration Specified\"\r\n\r\n    config = jsonic(config)\r\n    let collection = config['collection']\r\n    if (!collection) return \"No Collection Specified\"\r\n\r\n    // check if it is admin mode\r\n    let adminMode = false\r\n    if(config.admin == true) adminMode = true\r\n\r\n    let navigation_id = req.headers['x-app-key']\r\n    if (!navigation_id) return \"No X-App-Key specified\"\r\n\r\n    // form values\r\n    let data = Object.assign({}, req.query, req.body)\r\n\r\n    // retrieve data service\r\n    let ds = res.locals.ds\r\n    if (!ds) return \"No data service instantiated\"\r\n\r\n    // connect to database\r\n    await ds.connect()\r\n\r\n    // send delete query\r\n    let filter = { $and: [ { _id: ObjectID(`${data._id}`) } ] }\r\n    \r\n    return await ds.delete(collection, filter)\r\n}\r\n\r\nrun()\r\n"
},

/* 7 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000020"),
	"description" : "Upload document to the database",
	"name" : "MongoDB Upsert",
	"script" : "const hash = require(\"../lib/hash\");\r\n\r\nasync function verify(ds, config, verifyConfig, data, row) {\r\n  let result = false;\r\n\r\n  switch (verifyConfig.type) {\r\n    case \"MatchIfExists\":\r\n      {\r\n        if (row == null) {\r\n          // verify only when data exists\r\n          result = true;\r\n          break;\r\n        }\r\n        let source = row[verifyConfig.column];\r\n        if (!source) {\r\n          // verify only when data exists\r\n          result = true;\r\n        }\r\n\r\n        // is any algorithm applied?\r\n        switch (verifyConfig.algorithm) {\r\n          case \"encryption\":\r\n            {\r\n              let target = data[verifyConfig.field];\r\n              source = req.app.locals.encryption.decrypt(source);\r\n              result = source == target;\r\n            }\r\n            break;\r\n\r\n          case \"hash\":\r\n            {\r\n              let target = data[verifyConfig.field];\r\n              target = hash.hash(target);\r\n              result = source == target;\r\n            }\r\n            break;\r\n        }\r\n      }\r\n      break;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nasync function run() {\r\n  // read configuration\r\n  let config = res.locals.configuration;\r\n  if (!config) return { error: \"No Configuration Specified\" };\r\n\r\n  config = jsonic(config);\r\n  let collection = config[\"collection\"];\r\n  if (!collection) return { error: \"No Collection Specified\" };\r\n\r\n  // form values\r\n  let data = Object.assign({}, req.query, req.body);\r\n\r\n  // retrieve data service\r\n  let ds = res.locals.ds;\r\n  if (!ds) return { error: \"No data service instantiated\" };\r\n\r\n  // connect to database\r\n  await ds.connect();\r\n\r\n  // retrieve current data\r\n  let rows = await ds.find(config.collection, {\r\n    _id: ObjectID(data._id)\r\n  });\r\n  let row = null;\r\n  if (rows.length > 0) row = rows[0];\r\n\r\n  // verify data\r\n  if (config.verify) {\r\n    for (let verifyConfig of config.verify) {\r\n      let valid = await verify(ds, config, verifyConfig, data, row);\r\n      if (!valid) {\r\n        return { error: verifyConfig.message };\r\n      }\r\n    }\r\n  }\r\n\r\n  // set default field\r\n  if (config.defaultFields) {\r\n    for (let def of config.defaultFields) {\r\n      switch (def.type) {\r\n        case \"Date\":\r\n          if (data[def.column]) data[def.column] = new Date(data[def.column]);\r\n          break;\r\n        case \"NowIfNew\":\r\n          if (!row || !row[def.column]) {\r\n            data[def.column] = new Date();\r\n          } else if (data[def.column]) {\r\n            data[def.column] = new Date(data[def.column]);\r\n          }\r\n          break;\r\n        case \"Now\":\r\n          data[def.column] = new Date();\r\n          break;\r\n        case \"header\":\r\n          {\r\n            let value = req.headers[def.key];\r\n            if (!value) return { error: `No ${def.key} specified` };\r\n            data[def.column] = value;\r\n          }\r\n          break;\r\n        case \"hash\":\r\n          if (data[def.column]) data[def.column] = hash.hash(data[def.column]);\r\n          break;\r\n        case \"tokenIfNew\":\r\n          if(res.locals.token[def.key] && row && !row[def.column]) data[def.column] = res.locals.token[def.key]\r\n          break;\r\n        case \"Unique\": {\r\n          // do not create duplicate of the value\r\n          if (data[def.column]) {\r\n            // initialize row\r\n            if( !row ) row = {}\r\n            if( !row[def.column] ) row[def.column] = []\r\n\r\n            // check if the value exists\r\n            for(let value of data[def.column]) {\r\n              let item = row[def.column].find(x => x[def.key] == value[def.key])\r\n              if(!item) {\r\n                row[def.column].push(value)\r\n              }\r\n            }\r\n\r\n            // convert to array\r\n            data[def.column] = row[def.column]\r\n          }\r\n        }\r\n\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // encrypt fields\r\n  if (config.encryptedFields) {\r\n    for (let field of config.encryptedFields)\r\n      data[field] = req.app.locals.encryption.encrypt(data[field]);\r\n  }\r\n\r\n  // exclude fields\r\n  if (config.excludeFields) {\r\n    for (let field of config.excludeFields) delete data[field];\r\n  }\r\n\r\n  // upsert\r\n  let upsertedId = await ds.update(collection, data);\r\n\r\n  // return result\r\n  return { _id: upsertedId };\r\n}\r\n\r\nrun();\r\n"
},

/* 8 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000010"),
	"description" : "Get paginated, sorted, filtered, searched list",
	"name" : "MongoDB List",
	"script" : "var moment = require(\"moment-timezone\");\r\n\r\nfunction escapeRegExp(string) {\r\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\r\n}\r\n\r\nasync function run() {\r\n  // read configuration\r\n  let config = res.locals.configuration;\r\n  if (!config) return \"No Configuration Specified\";\r\n\r\n  config = jsonic(config);\r\n  let collection = config[\"collection\"];\r\n  if (!collection) return \"No Collection Specified\";\r\n\r\n  // form values\r\n  let data = Object.assign({}, req.query, req.body);\r\n\r\n  // pagination\r\n  let page = data.page || 1;\r\n  page = parseInt(page);\r\n  let size = data.size || 10;\r\n  size = parseInt(size);\r\n\r\n  // sort\r\n  let sort = null;\r\n  if (data._sort) {\r\n    sort = {};\r\n    sort[data._sort] = 1;\r\n  }\r\n  if (data._sort_desc) {\r\n    sort = {};\r\n    sort[data._sort_desc] = -1;\r\n  }\r\n\r\n  // build filter\r\n  let filter = { $and: [] };\r\n\r\n  // check if the configuration has filterFields\r\n  if (config.filterFields) {\r\n    for (let field of config.filterFields) {\r\n      switch (field.type) {\r\n        case \"header\":\r\n          {\r\n            let value = req.headers[field.key];\r\n            if (!value) return { error: `No ${field.key} specified` };\r\n            let f = {};\r\n            f[field.column] = value;\r\n\r\n            // add filter\r\n            filter[\"$and\"].push(f);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  let options = {};\r\n  for (let key of Object.keys(data)) {\r\n    if (key === \"page\") continue;\r\n    else if (key === \"size\") continue;\r\n    else if (key === \"_export\") continue;\r\n    else if (key === \"_aggregation\") continue;\r\n    else if (key === \"_sort\") continue;\r\n    else if (key === \"_sort_desc\") continue;\r\n    // _id gets ObjectId wrapper\r\n    else if (key === \"_id\") filter.$and.push({ _id: ObjectID(data[key]) });\r\n    // search\r\n    else if (key === \"_search\") {\r\n      if (data[key]) {\r\n        filter.$and.push({\r\n          $text: {\r\n            $search: data[key]\r\n          }\r\n        });\r\n        options = { score: { $meta: \"textScore\" } };\r\n        sort = { score: { $meta: \"textScore\" } };\r\n      }\r\n    }\r\n\r\n    // range\r\n    else if (key.endsWith(\"_date_gte\") || key.endsWith(\"_created_gte\")) {\r\n      let f = {};\r\n      f[key.replace(\"_gte\", \"\")] = { $gte: moment(data[key]).toDate() };\r\n      filter.$and.push(f);\r\n    } else if (key.endsWith(\"_date_gt\") || key.endsWith(\"_created_gt\")) {\r\n      let f = {};\r\n      f[key.replace(\"_gt\", \"\")] = { $gt: moment(data[key]).toDate() };\r\n      filter.$and.push(f);\r\n    } else if (key.endsWith(\"_date_lte\") || key.endsWith(\"_created_lte\")) {\r\n      let f = {};\r\n      f[key.replace(\"_lte\", \"\")] = { $lte: moment(data[key]).toDate() };\r\n      filter.$and.push(f);\r\n    } else if (key.endsWith(\"_date_lt\") || key.endsWith(\"_created_lt\")) {\r\n      let f = {};\r\n      f[key.replace(\"_lt\", \"\")] = { $lt: moment(data[key]).toDate() };\r\n      filter.$and.push(f);\r\n    }\r\n    // expression\r\n    else if (key.endsWith(\"$\")) {\r\n      let f = {};\r\n      f[key.substring(0, key.length - 1)] = eval(data[key]);\r\n      filter.$and.push(f);\r\n    }\r\n    // otherwise, string filter\r\n    else {\r\n      // if it is array make an or filter\r\n      if (Array.isArray(data[key])) {\r\n        let or = { $or: [] };\r\n        for (let v of data[key]) {\r\n          let f = {};\r\n          f[key] = v;\r\n          or.$or.push(f);\r\n        }\r\n        filter.$and.push(or);\r\n      } else if (data[key]) {\r\n        let f = {};\r\n        f[key] = new RegExp(escapeRegExp(data[key]), \"ig\");\r\n        filter.$and.push(f);\r\n      }\r\n    }\r\n  }\r\n\r\n  // if $and is empty then remove\r\n  if (filter.$and.length == 0) delete filter.$and;\r\n\r\n  // retrieve data service\r\n  let ds = res.locals.ds;\r\n  if (!ds) return \"No data service instantiated\";\r\n\r\n  // connect to database\r\n  await ds.connect();\r\n\r\n  // query to the collection\r\n  let result = [];\r\n  if (data._aggregation)\r\n    result = await ds.aggregate(collection, filter, jsonic(data._aggregation));\r\n  else\r\n    result = await ds.find(\r\n      collection,\r\n      filter,\r\n      sort,\r\n      size,\r\n      (page - 1) * size,\r\n      options\r\n    );\r\n  let total = await ds.count(collection, filter);\r\n\r\n  // remove fields\r\n  if (config.excludeFields) {\r\n    for (let row of result) {\r\n      for (let fields of config.excludeFields) {\r\n        if (row[fields]) delete row[fields];\r\n      }\r\n    }\r\n  }\r\n\r\n  // return result\r\n  return {\r\n    page: page,\r\n    size: result.length,\r\n    total: total,\r\n    filter: filter,\r\n    sort: sort,\r\n    websvc: res.locals.websvcurl,\r\n    data: result\r\n  };\r\n}\r\n\r\nrun();\r\n"
}