/* 1 createdAt:1/1/1970, 1:00:00 AM*/
{
	"_id" : ObjectId("000000000000000000000200"),
	"description" : "PDF",
	"name" : "Render PDF",
	"script" : "var Mustache = require('mustache');\r\nvar pdf = require('html-pdf');\r\nvar moment = require('moment')\r\n\r\nasync function run() {\r\n    // form values\r\n    let data = Object.assign({}, req.query, req.body)\r\n\r\n    // step 1. convert html template with data\r\n    if (res.locals.configuration.transform) {        \r\n        eval(res.locals.configuration.transform)\r\n    }\r\n        \r\n    var html = Mustache.render(res.locals.configuration.template, data);\r\n\r\n    // step 2. convert to pdf    \r\n    await (new Promise(function (resolve, reject) {        \r\n        pdf.create(html, res.locals.configuration.options).toBuffer(\r\n            function (err, buffer) {\r\n                res.setHeader('Content-disposition', `inline; filename=${(new Date()).getTime()}.pdf`);\r\n                res.end(buffer, 'binary')\r\n                resolve(true)\r\n            }\r\n        );\r\n    }))\r\n}\r\n\r\nrun()\r\n\r\n"
},

/* 2 createdAt:1/1/1970, 1:00:00 AM*/
{
	"_id" : ObjectId("000000000000000000000190"),
	"description" : "REST",
	"name" : "Call External REST",
	"script" : "var rp = require('request-promise-native');\r\n\r\nasync function run() {\r\n    \r\n    // read configuration\r\n    let config = res.locals.configuration\r\n    if (!config) return \"No Configuration Specified\"\r\n    \r\n    // form values\r\n    let data = Object.assign({}, req.query, req.body)\r\n    \r\n    // do something        \r\n    if(config.beforeSending) eval(config.beforeSending)\r\n    let options = eval(config.options)        \r\n    let response = await rp(options)\r\n    if(config.afterSending) eval(config.afterSending)\r\n    \r\n    return response\r\n}\r\n\r\nrun()\r\n"
},

/* 3 createdAt:1/1/1970, 1:00:00 AM*/
{
	"_id" : ObjectId("000000000000000000000180"),
	"description" : "Send Email",
	"name" : "Send Email",
	"script" : "var nodemailer = require('nodemailer');\n\nasync function run() {\n\n    // get navigation_id\n    let navigation_id = req.headers['x-app-key']\n    if (!navigation_id) return \"No X-App-Key specified\"\n\n    // form values\n    let data = Object.assign({}, req.query, req.body)\n\n    // retrieve data service\n    let ds = res.locals.ds\n    if (!ds) return { error: 'No data service instantiated' }\n\n    // connect to database\n    await ds.connect()\n\n    // get email configuration\n    let config = await ds.find('core.config', { _id: ObjectID(navigation_id) })\n    if (config.length == 0) return { error: \"Config doesn't exist\" }\n    config = config[0]\n\n    //\n    let user = config.smtp_user_name\n    if (!user) return { error: \"Username not specified\" }\n\n    let pass = req.app.locals.encryption.decrypt(config.smtp_password)\n    if (!pass) return { error: \"Password not specified\" }\n\n    // prepare server\n    let transporter = nodemailer.createTransport({\n        service: 'gmail',\n        auth: { user: user, pass: pass }\n    });\n\n    // prepare email context\n    var mailOptions = {\n        from: user,\n        to: data.to ? data.to.join() : '',\n        subject: data.title,\n        html: data.body\n    }\n\n    // see if there is a template\n    if (data.trigger && config.notification_templates) {\n        let template = config.notification_templates.find(x => x.trigger == data.trigger)\n        if (template) {\n            if (template.to) mailOptions.to = eval(template.to)\n            if (template.title) mailOptions.subject = eval(template.title)\n            if (template.body) mailOptions.html = eval(template.body)\n        }\n    }\n\n    // send email\n    if (mailOptions.to) return await sendemail(transporter, mailOptions)\n}\n\nasync function sendemail(transporter, mailOptions) {\n    return new Promise(function (resolve, reject) {\n        transporter.sendMail(mailOptions,\n            (error, info) => {\n                if (error) reject(error)\n                resolve(info)\n            })\n    })\n}\n\nrun()\n"
},

/* 4 createdAt:1/1/1970, 1:00:00 AM*/
{
	"_id" : ObjectId("000000000000000000000170"),
	"description" : "Dropbox Download",
	"name" : "Dropbox Download",
	"script" : "async function run() {\n\n    // get navigation id\n    let navigation_id = req.cookies['x-app-key']\n    if (!navigation_id) navigation_id = req.query.navigation_id\n    if (!navigation_id) return \"No X-App-Key specified\"\n\n    // retrieve data service\n    let ds = res.locals.ds\n    if (!ds) return \"No data service instantiated\"\n    // connect to database\n    await ds.connect()\n\n    // get dropbox token\n    let config = await ds.find('core.config', { _id: ObjectID(navigation_id) })\n    if (config.length == 0) return { error: \"Config doesn't exist\" }\n    config = config[0]\n    let dropbox_api_key = req.app.locals.encryption.decrypt(config.dropbox_api_key)\n    if (!dropbox_api_key) return { error: 'dropbox api key is required' }\n\n    // form values\n    let data = Object.assign({}, req.query, req.body)\n    // get uploaded filestream\n    let file = await download(dropbox_api_key, data.filepath)\n\n    // respond with file\n    res.setHeader('Content-disposition', `inline; filename=${file.name}`);\n    res.end(file.fileBinary, 'binary')\n\n    return\n}\n\nvar fetch = require('isomorphic-fetch'); // or another library of choice.\nvar Dropbox = require('dropbox').Dropbox;\n//\nasync function download(dropbox_api_key, filepath) {\n    return new Promise(function (resolve, reject) {\n        var dbx = new Dropbox({ accessToken: dropbox_api_key, fetch: fetch });\n        dbx.filesDownload({ path: filepath })\n            .then(function (file, error) {\n                if(error) reject(error)\n                resolve(file)\n            })\n            .catch(function (err) {\n                reject(err)\n            });\n    })\n}\n\nrun()\n"
},

/* 5 createdAt:1/1/1970, 1:00:00 AM*/
{
	"_id" : ObjectId("000000000000000000000160"),
	"description" : "Dropbox Upload",
	"name" : "Dropbox Upload",
	"script" : "async function run() {\n\n    // get navigation id\n    let navigation_id = req.headers['x-app-key']\n    if (!navigation_id) return \"No X-App-Key specified\"\n\n    // retrieve data service\n    let ds = res.locals.ds\n    if (!ds) return \"No data service instantiated\"\n    // connect to database\n    await ds.connect()\n\n    // get dropbox token\n    let config = await ds.find('core.config', { _id: ObjectID(navigation_id) })\n    if (config.length == 0) return { error: \"Config doesn't exist\" }\n    config = config[0]\n    let dropbox_api_key = req.app.locals.encryption.decrypt(config.dropbox_api_key)\n    if (!dropbox_api_key) return { error: 'dropbox api key is required' }\n\n    // folder path\n    let folderpath = req.query.folder\n    if (!folderpath) return { error: 'no folder path specified' }\n\n    // get uploaded filestream\n    let file = await fileContent()\n\n    // upload to dropbox\n    let saveTo = `/${folderpath}/${file.filename}`\n    let result = await upload(dropbox_api_key, saveTo, file.contents)\n    return [result]\n}\n\nasync function fileContent() {\n\n    return new Promise(function (resolve, reject) {\n        let _filename\n        var MemoryStream = require('memorystream');\n        var memStream = new MemoryStream(null, { readable: false });\n\n        req.busboy.on('file', function (fieldname, file, filename, encoding, mimetype) {\n            // save filename\n            _filename = filename\n\n            // write to the memory buffer\n            file.pipe(memStream)\n\n        });\n\n        req.busboy.on('finish', function () {\n            resolve({\n                filename: _filename,\n                contents: Buffer.concat(memStream.queue)\n            })\n        });\n\n        req.pipe(req.busboy);\n    })\n}\n\nvar fetch = require('isomorphic-fetch'); // or another library of choice.\nvar Dropbox = require('dropbox').Dropbox;\nasync function upload(dropbox_api_key, saveTo, contents) {\n    return new Promise(function (resolve, reject) {\n        var dbx = new Dropbox({ accessToken: dropbox_api_key, fetch: fetch });\n\n        dbx.filesUpload({ path: saveTo, contents: contents })\n            .then(function (response) {\n                resolve(saveTo);\n            })\n            .catch(function (err) {\n                res.status(500)\n                res.send(err)\n                reject(JSON.stringify(err));\n            });\n    })\n}\n\nrun()\n"
},

/* 6 createdAt:1/1/1970, 1:00:00 AM*/
{
	"_id" : ObjectId("000000000000000000000150"),
	"description" : "User Change Password",
	"name" : "User Change Password",
	"script" : "async function run() {\n    // check if it has admin mode set\n    let adminMode = false\n    if (res.locals.configuration) {\n        let config = jsonic(res.locals.configuration)\n        if(config.admin == true) adminMode = true\n    }\n\n    // form values\n    let data = Object.assign({}, req.query, req.body)\n\n    // get navigation id\n    let navigation_id = req.headers['x-app-key']\n    if (!navigation_id) return \"No X-App-Key specified\"\n    if(adminMode == true) navigation_id = data.navigation_id\n\n    // retrieve data service\n    let ds = res.locals.ds\n    if (!ds) return \"No data service instantiated\"\n\n    // error check\n    if( ! data.new_password ) return { error: 'new password missing' }\n    if( ! data.new_password_confirm && !adminMode ) return { error: 'repeated password missing' }\n    if( data.new_password_confirm != data.new_password && !adminMode ) return { error: 'new password and repeated password mismatch' }\n\n    // connect to database\n    await ds.connect()\n\n    // find the user\n    let filter = { $and: [ { navigation_id: navigation_id }, { _id: ObjectID(data._id) } ] }\n    let results = await ds.find('core.user', filter)\n    if( results.length == 0 ) return { error: 'user not found' }\n    let user = results[0]\n\n    // verify the password\n    if( adminMode == false )\n        // check if the password matches\n        if( user.password && user.password != hash.hash(data.old_password) )\n            return {error: `password doesn't match`}\n\n    // update password\n    user.password = hash.hash(data.new_password)\n    let id = await ds.update('core.user', user)\n\n    // return result\n    return { id: id }\n}\n\nrun()\n"
},

/* 7 createdAt:1/1/1970, 1:00:00 AM*/
{
	"_id" : ObjectId("000000000000000000000145"),
	"name" : "User Delete",
	"description" : "User Delete",
	"script" : "async function deleteGroup(ds, navigation_id, user_id) {\r\n    return new Promise(function (resolve, reject) {\r\n        // remove the user from all the group\r\n        ds.db.collection('core.group')\r\n            .updateMany(\r\n                { navigation_id: navigation_id }\r\n                , { $pull: { users: user_id } }\r\n                , (err, res) => {\r\n                    if (err) reject(err)\r\n                    resolve(true)\r\n                }\r\n            )\r\n\r\n\r\n    })\r\n}\r\n\r\nasync function run() {\r\n\r\n    // get navigation_id\r\n    let navigation_id = req.headers['x-app-key']\r\n    if (!navigation_id) return \"No X-App-Key specified\"\r\n\r\n    // form values\r\n    let data = Object.assign({}, req.query, req.body)\r\n\r\n    // retrieve data service\r\n    let ds = res.locals.ds\r\n    if (!ds) return { error: 'No data service instantiated' }\r\n\r\n    // connect to database\r\n    await ds.connect()\r\n\r\n    // Find user\r\n    let filter = { $and: [{ navigation_id: navigation_id }, { _id: ObjectID(`${data._id}`) }] }\r\n    let users = await ds.find('core.user', filter)\r\n    if( users.length == 0 ) return {error: 'user not found'}\r\n\r\n    // delete group\r\n    if( true == await deleteGroup(ds, navigation_id, `${users[0]._id}`) ) {\r\n\r\n        // delete user\r\n        return await ds.delete('core.user', filter)\r\n\r\n    }\r\n}\r\n\r\nrun()\r\n"
},

/* 8 createdAt:1/1/1970, 1:00:00 AM*/
{
	"_id" : ObjectId("000000000000000000000140"),
	"description" : "User Upsert",
	"name" : "User Upsert",
	"script" : "async function setDefaultData(data, navigation_id) {\n    // convert to date field\n    for (let field of Object.keys(data))\n        if (field.endsWith('_date'))\n            data[field] = new Date(data[field])\n\n    // convert _created\n    data._created = data._created ? new Date(data._created) : new Date()\n    data._updated = new Date()\n\n    // asign navigation_id\n    data.navigation_id = navigation_id\n}\n\nasync function updateGroup(ds, navigation_id, group_ids, user_id) {\n    return new Promise(function (resolve, reject) {\n        // remove the user from all the group\n        ds.db.collection('core.group')\n            .updateMany(\n                { navigation_id: navigation_id }\n                , { $pull: { users: user_id } }\n                , (err, res) => {\n                    if (err) reject(err)\n\n                    // add user to the specified group\n                    ds.db.collection('core.group')\n                        .updateMany(\n                            { $and: [{ navigation_id: navigation_id }, { _id: { $in: group_ids.map(x => ObjectID(`${x}`)) } }] }\n                            , { $push: { users: user_id } }\n                            , (err, res) => {\n                                if (err) reject(err)\n                                resolve(true)\n                            }\n                        )\n\n                }\n            )\n\n\n    })\n}\n\nasync function run() {\n\n    // check if it is admin mode\n    let adminMode = false\n    if(res.locals.configuration) {\n        let config = jsonic(res.locals.configuration)\n        if(config.admin == true) adminMode = true\n    }\n\n    // form values\n    let data = Object.assign({}, req.query, req.body)\n\n    // get navigation_id\n    let navigation_id = req.headers['x-app-key']\n    if (!navigation_id) return {error: \"No X-App-Key specified\"}\n    if(adminMode == true) navigation_id = data.navigation_id\n\n    // Get Group ID\n    let group_ids = data.group_id\n    if (!group_ids || group_ids.Length == 0) return { error: 'No Group Specified.' }\n\n    // data validation - id and password is mandatory\n    if (!data.id) return { error: 'id is mandatory field' }\n\n    // retrieve data service\n    let ds = res.locals.ds\n    if (!ds) return { error: 'No data service instantiated' }\n\n    // connect to database\n    await ds.connect()\n\n    // if user exists then process as existing user\n    // if _id exists - Is it existing user?\n    if (data._id) {\n        // Find user\n        let filter = { $and: [{ _id: ObjectID(`${data._id}`) }] }\n        let users = await ds.find('core.user', filter)\n         if (users.length > 0) {\n            let user = users[0]\n\n            // check if the password matches\n            if( data.password && user.password != data.password )\n                if (user.password != hash.hash(data.password))\n                    return { error: `password doesn't match` }\n\n            // update user password\n            if( data.password ) data.password = hash.hash(data.password)\n\n            // process default fields\n            setDefaultData(data, navigation_id)\n            let updatedUserId = await ds.update('core.user', data);\n\n            // update group\n            await updateGroup(ds, navigation_id, group_ids, `${updatedUserId}`)\n\n            return { _id: updatedUserId }\n        }\n    }\n    else {\n        // Find user\n        let filter = { $and: [{ navigation_id: navigation_id }, { id: data.id }] }\n        let users = await ds.find('core.user', filter)\n        if (users.length > 0) return { error: 'same id already exists' }\n\n        // new user creation\n        data.password = hash.hash(`${data.password || 12345678}`)\n\n        // process default fields\n        setDefaultData(data, navigation_id)\n        let updatedUserId = await ds.update('core.user', data);\n\n        // update group\n        await updateGroup(ds, navigation_id, group_ids, `${updatedUserId}`)\n\n        return { _id: updatedUserId }\n    }\n\n    return {error: 'no matching user found'}\n\n}\n\nrun()\n"
},

/* 9 createdAt:1/1/1970, 1:00:00 AM*/
{
	"_id" : ObjectId("000000000000000000000030"),
	"description" : "Delete an item",
	"name" : "MongoDB Delete",
	"script" : "async function run() {\n    // read configuration\n    let config = res.locals.configuration\n    if (!config) return \"No Configuration Specified\"\n\n    config = jsonic(config)\n    let collection = config['collection']\n    if (!collection) return \"No Collection Specified\"\n\n    // check if it is admin mode\n    let adminMode = false\n    if(config.admin == true) adminMode = true\n\n    let navigation_id = req.headers['x-app-key']\n    if (!navigation_id) return \"No X-App-Key specified\"\n\n    // form values\n    let data = Object.assign({}, req.query, req.body)\n\n    // retrieve data service\n    let ds = res.locals.ds\n    if (!ds) return \"No data service instantiated\"\n\n    // connect to database\n    await ds.connect()\n\n    // send delete query\n    let filter = { $and: [ { navigation_id: navigation_id }, { _id: ObjectID(`${data._id}`) } ] }\n    // do not filter by navigation_id if it is adminmode\n    if( adminMode == true ) filter.$and = [ { _id: ObjectID(`${data._id}`) } ]\n\n    return await ds.delete(collection, filter)\n}\n\nrun()\n"
},

/* 10 createdAt:1/1/1970, 1:00:00 AM*/
{
	"_id" : ObjectId("000000000000000000000020"),
	"description" : "Upload document to the database",
	"name" : "MongoDB Upsert",
	"script" : "function encryptSensitiveFields(data, sensitive) {\n\n    // remove sensitive fields\n    for (let fields of Object.keys(sensitive)) {\n        if (data[fields]) {\n            data[fields] = req.app.locals.encryption.encrypt(data[fields])\n        }\n    }\n\n}\n\n\nasync function setDefaultData(data, navigation_id) {\n    // convert to date field\n    for (let field of Object.keys(data))\n        if (field.endsWith('_date'))\n            data[field] = new Date(data[field])\n\n    // convert _created\n    data._created = data._created ? new Date(data._created) : new Date()\n    data._updated = new Date()\n\n    // asign navigation_id\n    data.navigation_id = navigation_id\n}\n\nasync function run() {\n    // read configuration\n    let config = res.locals.configuration\n    if (!config) return {error: \"No Configuration Specified\"}\n\n    config = jsonic(config)\n    let collection = config['collection']\n    if (!collection) return {error: \"No Collection Specified\"}\n\n    // check if it is admin mode\n    let adminMode = false; if (config.admin == true) adminMode = true\n\n    // check if it has sensitive fields\n    let sensitive; if (config.sensitive) sensitive = config.sensitive\n\n    // form values\n    let data = Object.assign({}, req.query, req.body)\n\n    let navigation_id = req.headers['x-app-key']\n    if (!navigation_id) return {error: \"No X-App-Key specified\"}\n    if (adminMode) navigation_id = data.navigation_id\n\n    // retrieve data service\n    let ds = res.locals.ds\n    if (!ds) return {error: \"No data service instantiated\"}\n\n    // connect to database\n    await ds.connect()\n\n    // process to setup a default field\n    setDefaultData(data, navigation_id)\n\n    // process to encrypt sensitive data\n    if (sensitive) encryptSensitiveFields(data, sensitive)\n\n    // upsert\n    let upsertedId = await ds.update(collection, data)\n\n    // return result\n    return { _id: upsertedId }\n\n}\n\nrun()\n"
},

/* 11 createdAt:1/1/1970, 1:00:00 AM*/
{
	"_id" : ObjectId("000000000000000000000010"),
	"description" : "Get paginated, sorted, filtered, searched list",
	"name" : "MongoDB List",
	"script" : "function removeSensitiveFields(rows, sensitive) {\r\n\r\n    // remove sensitive fields\r\n    for(let row of rows) {\r\n        for(let fields of Object.keys(sensitive)) {\r\n            if(row[fields]) delete row[fields]\r\n        }\r\n    }\r\n\r\n}\r\n\r\nasync function run() {\r\n    // read configuration\r\n    let config = res.locals.configuration\r\n    if (!config) return \"No Configuration Specified\"\r\n\r\n    config = jsonic(config)\r\n    let collection = config['collection']\r\n    if (!collection) return \"No Collection Specified\"\r\n\r\n    // check if it is admin mode\r\n    let adminMode = false; if(config.admin == true) adminMode = true\r\n\r\n    // check if it has sensitive fields\r\n    let sensitive; if(config.sensitive) sensitive = config.sensitive\r\n\r\n    let navigation_id = req.headers['x-app-key']\r\n    if (!navigation_id) return \"No X-App-Key specified\"\r\n\r\n    // form values\r\n    let data = Object.assign({}, req.query, req.body)\r\n\r\n    // pagination\r\n    let page = data.page || 1\r\n    page = parseInt(page)\r\n    let size = data.size || 10\r\n    size = parseInt(size)\r\n\r\n    // if export is specified then increase the size\r\n    if (data._export) size = '10000'\r\n\r\n    // sort\r\n    let sort = null\r\n    if (data._sort) {\r\n        sort = {}; sort[data._sort] = 1;\r\n    }\r\n    if (data._sort_desc) {\r\n        sort = {}; sort[data._sort_desc] = -1;\r\n    }\r\n\r\n    // build filter\r\n    let filter = { $and: [ { navigation_id: navigation_id } ] }\r\n    let options = {}\r\n\r\n    // do not filter by navigation_id if it is adminmode\r\n    if( adminMode == true ) filter.$and = [ { _id: {$exists: true} } ]\r\n\r\n    for (let key of Object.keys(data)) {\r\n        if (key === 'page') continue;\r\n        else if (key === 'size') continue;\r\n        else if (key === '_export') continue;\r\n        else if (key === '_aggregation') continue;\r\n        else if (key === '_sort') continue;\r\n        else if (key === '_sort_desc') continue;\r\n\r\n        // _id gets ObjectId wrapper\r\n        else if (key === '_id') filter.$and.push({ _id: ObjectID(data[key]) })\r\n\r\n        // search\r\n        else if (key === '_search') {\r\n            if(data[key]) {\r\n                filter.$and.push({ $text: {\r\n                    $search: data[key]\r\n                } })\r\n                options = {score : { $meta: \"textScore\" } }\r\n                sort = {score : { $meta: \"textScore\" } }\r\n            }\r\n        }\r\n\r\n        // range\r\n        else if (key.endsWith(\"_date_gte\")) {\r\n            let f = {}; f[key.replace('_gte', '')] = { $gte: new Date(data[key]) }; filter.$and.push(f);\r\n        }\r\n        else if (key.endsWith(\"_date_gt\")) {\r\n            let f = {}; f[key.replace('_gt', '')] = { $gt: new Date(data[key]) }; filter.$and.push(f);\r\n        }\r\n        else if (key.endsWith(\"_date_lte\")) {\r\n            let f = {}; f[key.replace('_lte', '')] = { $lte: new Date(data[key]) }; filter.$and.push(f);\r\n        }\r\n        else if (key.endsWith(\"_date_lt\")) {\r\n            let f = {}; f[key.replace('_lt', '')] = { $lt: new Date(data[key]) }; filter.$and.push(f);\r\n        }\r\n        // expression\r\n        else if (key.endsWith(\"$\")) {\r\n            let f = {};\r\n            f[key.substring(0, key.length-1)] = eval(data[key]);\r\n            filter.$and.push(f)\r\n        }\r\n        // otherwise, string filter\r\n        else {\r\n            // if it is array make an or filter\r\n            if( Array.isArray(data[key]) ) {\r\n                let or = { $or: [] }\r\n                for(let v of data[key]) {\r\n                    let f = {}; f[key] = v\r\n                    or.$or.push(f)\r\n                }\r\n                filter.$and.push(or)\r\n            }\r\n            else {\r\n                let f = {}; f[key] = new RegExp(data[key],\"ig\"); filter.$and.push(f)\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    // retrieve data service\r\n    let ds = res.locals.ds\r\n    if (!ds) return \"No data service instantiated\"\r\n\r\n    // connect to database\r\n    await ds.connect()\r\n\r\n    // query to the collection\r\n    let result = []\r\n    if( data._aggregation ) result = await ds.aggregate(collection, filter, jsonic(data._aggregation))\r\n    else result = await ds.find(collection, filter, sort, size, (page -1)*size, options)\r\n    let total = await ds.count(collection, filter)\r\n\r\n    // remove sensitive fields\r\n    if(sensitive) removeSensitiveFields(result, sensitive)\r\n\r\n    // return result\r\n    return {\r\n        page: page,\r\n        size: result.length,\r\n        total: total,\r\n        filter: filter,\r\n        sort: sort,\r\n        websvc: res.locals.websvcurl,\r\n        data: result\r\n    }\r\n}\r\n\r\nrun()\r\n"
}