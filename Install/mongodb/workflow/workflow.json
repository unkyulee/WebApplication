/* 1 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000200"),
	"description" : "PDF",
	"name" : "Render PDF",
	"script" : "var Mustache = require(\"mustache\");\r\nvar pdf = require(\"html-pdf\");\r\nvar moment = require(\"moment-timezone\");\r\n\r\n(async function() {\r\n  // form values\r\n  let data = Object.assign({}, req.query, req.body);\r\n\r\n  // load from the database\r\n  await res.locals.ds.connect();\r\n  data = await res.locals.ds.find(data.collection, {\r\n    _id: ObjectID(data._id)\r\n  });\r\n\r\n  // take the first row\r\n  data = data[0]\r\n\r\n  // transform\r\n  eval(res.locals.configuration.transform)\r\n\r\n  // prepare html\r\n  var html = Mustache.render(res.locals.configuration.template, data);\r\n\r\n  // convert html to pdf\r\n  await new Promise(function(resolve, reject) {\r\n    pdf\r\n      .create(html, res.locals.configuration.options)\r\n      .toBuffer(function(err, buffer) {\r\n        res.setHeader(\r\n          \"Content-disposition\",\r\n          `inline; filename=${new Date().getTime()}.pdf`\r\n        );\r\n        res.end(buffer, \"binary\");\r\n        resolve(true);\r\n      });\r\n  });\r\n\r\n})();\r\n"
},

{
  "_id": "000000000000000000000210",
  "name": "EXCEL",
  "script": "const excel = require('node-excel-export');\r\n\r\n(async function () {\r\n\t// form values\r\n\tlet params = Object.assign({}, req.query, req.body);\r\n\r\n\t// load config\r\n\tawait res.locals.ds.connect();\r\n\r\n\tlet config;\r\n\tif (params.template) {\r\n\t\t// load from template\r\n\t\tconfig = await res.locals.ds.find('core.ui', {\r\n\t\t\tquery: {\r\n\t\t\t\t_id: ObjectID(params.template),\r\n\t\t\t},\r\n\t\t});\r\n\t\tconfig = config[0];\r\n\t} else {\r\n\t\t// load from custom config\r\n\t\tconfig = await res.locals.ds.find('config', {\r\n\t\t\tquery: {\r\n\t\t\t\tcompany_id: ObjectID(req.cookies['company_id']),\r\n\t\t\t\ttype: 'excel',\r\n\t\t\t\tpdf: params.excel,\r\n\t\t\t},\r\n\t\t});\r\n\t\tconfig = config[0];\r\n\t}\r\n\r\n\tif (!config) {\r\n\t\tres.status(500);\r\n\t\tres.send(`configuration does not exist for ${req.cookies['company_id']} of pdf ${params.pdf}`);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// transform\r\n\tlet options = await eval(config.data);\r\n\r\n\t// prepare excel\r\n\tconst report = excel.buildExport(options);\r\n\r\n\t// send file\r\n\tres.setHeader('Content-disposition', `inline; filename=${new Date().getTime()}.xlsx`);\r\n\tres.end(report, 'binary');\r\n})();\r\n"
}

/* 2 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000190"),
	"description" : "REST",
	"name" : "Call External REST",
	"script" : "var rp = require('request-promise-native');\r\n\r\nasync function run() {\r\n    \r\n    // read configuration\r\n    let config = res.locals.configuration\r\n    if (!config) return \"No Configuration Specified\"\r\n    \r\n    // form values\r\n    let data = Object.assign({}, req.query, req.body)\r\n    \r\n    // do something        \r\n    if(config.beforeSending) eval(config.beforeSending)\r\n    let options = eval(config.options)        \r\n    let response = await rp(options)\r\n    if(config.afterSending) eval(config.afterSending)\r\n    \r\n    return response\r\n}\r\n\r\nrun()\r\n"
},

/* 3 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000180"),
	"description" : "Send Email",
	"name" : "Send Email",
	"script" : "var nodemailer = require('nodemailer');\n\nasync function run() {\n\n    // get navigation_id\n    let navigation_id = req.headers['x-app-key']\n    if (!navigation_id) return \"No X-App-Key specified\"\n\n    // form values\n    let data = Object.assign({}, req.query, req.body)\n\n    // retrieve data service\n    let ds = res.locals.ds\n    if (!ds) return { error: 'No data service instantiated' }\n\n    // connect to database\n    await ds.connect()\n\n    // get email configuration\n    let config = await ds.find('core.config', { _id: ObjectID(navigation_id) })\n    if (config.length == 0) return { error: \"Config doesn't exist\" }\n    config = config[0]\n\n    //\n    let user = config.smtp_user_name\n    if (!user) return { error: \"Username not specified\" }\n\n    let pass = req.app.locals.encryption.decrypt(config.smtp_password)\n    if (!pass) return { error: \"Password not specified\" }\n\n    // prepare server\n    let transporter = nodemailer.createTransport({\n        service: 'gmail',\n        auth: { user: user, pass: pass }\n    });\n\n    // prepare email context\n    var mailOptions = {\n        from: user,\n        to: data.to ? data.to.join() : '',\n        subject: data.title,\n        html: data.body\n    }\n\n    // see if there is a template\n    if (data.trigger && config.notification_templates) {\n        let template = config.notification_templates.find(x => x.trigger == data.trigger)\n        if (template) {\n            if (template.to) mailOptions.to = eval(template.to)\n            if (template.title) mailOptions.subject = eval(template.title)\n            if (template.body) mailOptions.html = eval(template.body)\n        }\n    }\n\n    // send email\n    if (mailOptions.to) return await sendemail(transporter, mailOptions)\n}\n\nasync function sendemail(transporter, mailOptions) {\n    return new Promise(function (resolve, reject) {\n        transporter.sendMail(mailOptions,\n            (error, info) => {\n                if (error) reject(error)\n                resolve(info)\n            })\n    })\n}\n\nrun()\n"
},

/* 4 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000170"),
	"description" : "Dropbox Download",
	"name" : "Dropbox Download",
	"script" : "var fetch = require(\"isomorphic-fetch\"); // or another library of choice.\r\nvar Dropbox = require(\"dropbox\").Dropbox;\r\n\r\nasync function run() {\r\n  // get navigation id\r\n  let company_id = req.cookies[\"company_id\"];\r\n  if (!company_id) company_id = req.query.company_id;\r\n  if (!company_id) return \"No company_id specified\";\r\n\r\n  // retrieve data service\r\n  let ds = res.locals.ds;\r\n  if (!ds) return \"No data service instantiated\";\r\n  // connect to database\r\n  await ds.connect();\r\n\r\n  // retrieve config\r\n  let config = await ds.find(\"config\", {\r\n    query: {\r\n      company_id: ObjectID(company_id),\r\n      type: \"dropbox\"\r\n    }\r\n  });\r\n  if (config.length == 0) return { error: \"Config doesn't exist\" };\r\n  config = config[0];\r\n\r\n  // retrieve dropbox_api_key\r\n  let dropbox_api_key = req.app.locals.encryption.decrypt(\r\n    config.dropbox_api_key\r\n  );\r\n  if (!dropbox_api_key) return { error: \"dropbox api key is required\" };\r\n\r\n  // form values\r\n  let data = Object.assign({}, req.query, req.body);\r\n\r\n  // get uploaded filestream\r\n  let file = await download(dropbox_api_key, data.filepath);\r\n\r\n  // respond with file\r\n  res.setHeader(\r\n    \"Content-disposition\",\r\n    `inline; filename=${encodeURIComponent(file.name)}`\r\n  );\r\n  res.end(file.fileBinary, \"binary\");\r\n  return;\r\n}\r\n\r\n//\r\nasync function download(dropbox_api_key, filepath) {\r\n  return new Promise(function(resolve, reject) {\r\n    var dbx = new Dropbox({ accessToken: dropbox_api_key, fetch: fetch });\r\n    dbx\r\n      .filesDownload({ path: filepath })\r\n      .then(function(file, error) {\r\n        if (error) reject(error);\r\n        resolve(file);\r\n      })\r\n      .catch(function(err) {\r\n        reject(err);\r\n      });\r\n  });\r\n}\r\n\r\nrun();\r\n"
},

/* 5 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000160"),
	"description" : "Dropbox Upload",
	"name" : "Dropbox Upload",
	"script" : "async function run() {\r\n\r\n  // get navigation id\r\n  let company_id = req.headers[\"company_id\"];\r\n  if (!company_id) return \"No company_id specified\";\r\n\r\n  // retrieve data service\r\n  let ds = res.locals.ds;\r\n  if (!ds) return \"No data service instantiated\";\r\n\r\n  // connect to database\r\n  await ds.connect();\r\n\r\n  // get dropbox token\r\n  let config = await ds.find(\"config\", {\r\n    query: {\r\n      company_id: ObjectID(company_id),\r\n      type: \"dropbox\"\r\n    }\r\n  });\r\n  if (config.length == 0) return { error: \"Config doesn't exist\" };\r\n  config = config[0];\r\n\r\n  // get dropbox_api_key\r\n  let dropbox_api_key = req.app.locals.encryption.decrypt(\r\n    config.dropbox_api_key\r\n  );\r\n  if (!dropbox_api_key) return { error: \"dropbox api key is required\" };\r\n\r\n  // folder path\r\n  let folderpath = req.query.folder;\r\n  if (!folderpath) return { error: \"no folder path specified\" };\r\n\r\n  // get uploaded filestream\r\n  let file = await fileContent();\r\n\r\n  // upload to dropbox\r\n  folderpath = folderpath.trim();\r\n  let saveTo = `/${encodeNonAsciiCharacters(\r\n    folderpath\r\n  )}/${encodeNonAsciiCharacters(file.filename)}`;\r\n  let result = await upload(dropbox_api_key, saveTo, file.contents);\r\n  return [result];\r\n}\r\n\r\nasync function fileContent() {\r\n  return new Promise(function(resolve, reject) {\r\n    let _filename;\r\n    var MemoryStream = require(\"memorystream\");\r\n    var memStream = new MemoryStream(null, { readable: false });\r\n\r\n    req.busboy.on(\"file\", function(\r\n      fieldname,\r\n      file,\r\n      filename,\r\n      encoding,\r\n      mimetype\r\n    ) {\r\n      // save filename\r\n      _filename = filename;\r\n\r\n      // write to the memory buffer\r\n      file.pipe(memStream);\r\n    });\r\n\r\n    req.busboy.on(\"finish\", function() {\r\n      resolve({\r\n        filename: _filename,\r\n        contents: Buffer.concat(memStream.queue)\r\n      });\r\n    });\r\n\r\n    req.pipe(req.busboy);\r\n  });\r\n}\r\n\r\nvar fetch = require(\"isomorphic-fetch\"); // or another library of choice.\r\nvar Dropbox = require(\"dropbox\").Dropbox;\r\nasync function upload(dropbox_api_key, saveTo, contents) {\r\n  return new Promise(function(resolve, reject) {\r\n    var dbx = new Dropbox({ accessToken: dropbox_api_key, fetch: fetch });\r\n\r\n    dbx\r\n      .filesUpload({\r\n        path: saveTo,\r\n        contents: contents\r\n      })\r\n      .then(function(response) {\r\n        resolve(encodeURIComponent(saveTo));\r\n      })\r\n      .catch(function(err) {\r\n        res.status(500);\r\n        res.send(err);\r\n        reject(JSON.stringify(err));\r\n      });\r\n  });\r\n}\r\n\r\nfunction encodeNonAsciiCharacters(value) {\r\n  let out = \"\";\r\n  for (let i = 0; i < value.length; i++) {\r\n    const ch = value.charAt(i);\r\n    let chn = ch.charCodeAt(0);\r\n    if (chn <= 127) out += ch;\r\n    else {\r\n      let hex = chn.toString(16);\r\n      if (hex.length < 4) hex = \"000\".substring(hex.length - 1) + hex;\r\n      out += \"\\\\u\" + hex;\r\n    }\r\n  }\r\n  return out;\r\n}\r\n\r\nrun();\r\n"
},

/* 9 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000030"),
	"description" : "Delete an item",
	"name" : "MongoDB Delete",
	"script" : "async function run() {\r\n    // read configuration\r\n    let config = res.locals.configuration\r\n    if (!config) return \"No Configuration Specified\"\r\n\r\n    config = jsonic(config)\r\n    let collection = config['collection']\r\n    if (!collection) return \"No Collection Specified\"\r\n\r\n    // check if it is admin mode\r\n    let adminMode = false\r\n    if(config.admin == true) adminMode = true\r\n\r\n    let navigation_id = req.headers['company_id']\r\n    if (!navigation_id) return \"No company_id specified\"\r\n\r\n    // form values\r\n    let data = Object.assign({}, req.query, req.body)\r\n\r\n    // retrieve data service\r\n    let ds = res.locals.ds\r\n    if (!ds) return \"No data service instantiated\"\r\n\r\n    // connect to database\r\n    await ds.connect()\r\n\r\n    // send delete query\r\n    let filter = { $and: [ { _id: ObjectID(`${data._id}`) } ] }\r\n\r\n    return await ds.delete(collection, filter)\r\n}\r\n\r\nrun()\r\n"
},

/* 10 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000020"),
	"description" : "Upload document to the database",
	"name" : "MongoDB Upsert",
	"script" : "const hash = require(\"../lib/hash\");\r\nconst obj = require(\"object-path\");\r\n\r\nasync function verify(ds, config, verifyConfig, data, row) {\r\n  let result = false;\r\n\r\n  switch (verifyConfig.type) {\r\n    case \"MatchIfExists\":\r\n      {\r\n        if (row == null) {\r\n          // verify only when data exists\r\n          result = true;\r\n          break;\r\n        }\r\n        let source = row[verifyConfig.column];\r\n        if (!source) {\r\n          // verify only when data exists\r\n          result = true;\r\n        }\r\n\r\n        // is any algorithm applied?\r\n        switch (verifyConfig.algorithm) {\r\n          case \"encryption\":\r\n            {\r\n              let target = data[verifyConfig.field];\r\n              if (target) {\r\n                source = req.app.locals.encryption.decrypt(source);\r\n                result = source == target;\r\n              } else {\r\n                result = true;\r\n              }\r\n            }\r\n            break;\r\n\r\n          case \"hash\":\r\n            {\r\n              let target = data[verifyConfig.field];\r\n              if (target) {\r\n                target = hash.hash(target);\r\n                result = source == target;\r\n              } else {\r\n                // if value doesn't exist?\r\n                result = true;\r\n              }\r\n            }\r\n            break;\r\n        }\r\n      }\r\n      break;\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\nasync function run() {\r\n  // read configuration\r\n  let config = res.locals.configuration;\r\n  if (!config) return { error: \"No Configuration Specified\" };\r\n\r\n  config = jsonic(config);\r\n  let collection = config[\"collection\"];\r\n  if (!collection) return { error: \"No Collection Specified\" };\r\n\r\n  // form values\r\n  let data = Object.assign({}, req.query, req.body);\r\n\r\n  // retrieve data service\r\n  let ds = res.locals.ds;\r\n  if (!ds) return { error: \"No data service instantiated\" };\r\n\r\n  // connect to database\r\n  await ds.connect();\r\n\r\n  // retrieve current data\r\n  let rows = await ds.find(config.collection, {\r\n    query: {\r\n      _id: ObjectID(data._id)\r\n    }\r\n  });\r\n  let row = null;\r\n  if (rows.length > 0) row = rows[0];\r\n\r\n  // verify data\r\n  if (config.verify) {\r\n    for (let verifyConfig of config.verify) {\r\n      let valid = await verify(ds, config, verifyConfig, data, row);\r\n      if (!valid) {\r\n        return { error: verifyConfig.message };\r\n      }\r\n    }\r\n  }\r\n\r\n  // set default field\r\n  if (config.defaultFields) {\r\n    for (let def of config.defaultFields) {\r\n      switch (def.type) {\r\n        case \"Date\":\r\n          if (data[def.column]) data[def.column] = new Date(data[def.column]);\r\n          break;\r\n        case \"DateInArray\":\r\n          {\r\n            let array = obj.get(data, def.path);\r\n            if (array) {\r\n              for (let v of array) {\r\n                if (v[def.column]) {\r\n                  v[def.column] = new Date(v[def.column]);\r\n                }\r\n              }\r\n            }\r\n          }\r\n          break;\r\n        case \"NowIfNew\":\r\n          if ((!row || !row[def.column]) && !data[def.column]) {\r\n            data[def.column] = new Date();\r\n          } else if (data[def.column]) {\r\n            data[def.column] = new Date(data[def.column]);\r\n          }\r\n          break;\r\n        case \"Now\":\r\n          data[def.column] = new Date();\r\n          break;\r\n        case \"header\":\r\n          {\r\n            let value = req.headers[def.key];\r\n            if (!value) return { error: `No ${def.key} specified` };\r\n            if (def.column == \"company_id\") value = ObjectID(value);\r\n            data[def.column] = value;\r\n          }\r\n          break;\r\n        case \"hash\":\r\n          if (data[def.column]) data[def.column] = hash.hash(data[def.column]);\r\n          break;\r\n        case \"tokenIfNew\":\r\n          if (\r\n            res.locals.token[def.key] &&\r\n            (!row || (row && !row[def.column]))\r\n          ) {\r\n            data[def.column] = res.locals.token[def.key];\r\n          }\r\n          break;\r\n        case \"Unique\":\r\n          {\r\n            // do not create duplicate of the value\r\n            if (data[def.column]) {\r\n              // initialize row\r\n              if (!row) row = {};\r\n              if (!row[def.column]) row[def.column] = [];\r\n\r\n              // check if the value exists\r\n              for (let value of data[def.column]) {\r\n                let item = row[def.column].find(\r\n                  x => x[def.key] == value[def.key]\r\n                );\r\n                if (!item) {\r\n                  row[def.column].push(value);\r\n                }\r\n              }\r\n\r\n              // convert to array\r\n              data[def.column] = row[def.column];\r\n            }\r\n          }\r\n          break;\r\n        case \"ObjectID\":\r\n          if (data[def.column]) {\r\n            if (Array.isArray(data[def.column])) {\r\n              data[def.column] = data[def.column].map(x => ObjectID(x));\r\n            } else data[def.column] = ObjectID(data[def.column]);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // encrypt fields\r\n  if (config.encryptedFields) {\r\n    for (let field of config.encryptedFields) {\r\n      if (data[field]) {\r\n        data[field] = req.app.locals.encryption.encrypt(data[field]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // exclude fields\r\n  if (config.excludeFields) {\r\n    for (let field of config.excludeFields) delete data[field];\r\n  }\r\n\r\n  // upsert\r\n  let upsertedId = null;\r\n  if (row) {\r\n    upsertedId = await ds.update(collection, data);\r\n  } else {\r\n    upsertedId = await ds.insert(collection, data);\r\n  }\r\n\r\n  // return result\r\n  return { _id: upsertedId };\r\n}\r\n\r\nrun();\r\n"
},

/* 11 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : ObjectId("000000000000000000000010"),
	"description" : "Get paginated, sorted, filtered, searched list",
	"name" : "MongoDB List",
	"script" : "var moment = require(\"moment-timezone\");\r\nvar obj = require(\"object-path\");\r\n\r\nfunction escapeRegExp(string) {\r\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"); // $& means the whole matched string\r\n}\r\n\r\nasync function run() {\r\n  // read configuration\r\n  let config = res.locals.configuration;\r\n  if (!config) return \"No Configuration Specified\";\r\n\r\n  config = jsonic(config);\r\n  let collection = config[\"collection\"];\r\n  if (!collection) return \"No Collection Specified\";\r\n\r\n  // form values\r\n  let data = Object.assign({}, req.query, req.body);\r\n\r\n  // pagination\r\n  let page = data.page || 1;\r\n  page = parseInt(page);\r\n  let size = data.size || 10;\r\n  size = parseInt(size);\r\n\r\n  // sort\r\n  let sort = null;\r\n  if (data._sort) {\r\n    sort = {};\r\n    sort[data._sort] = 1;\r\n  }\r\n  if (data._sort_desc) {\r\n    sort = {};\r\n    sort[data._sort_desc] = -1;\r\n  }\r\n  if(sort == null) {\r\n    sort = {};\r\n    sort['_created'] = -1;\r\n  }\r\n\r\n  // build filter\r\n  let filter = { $and: [] };\r\n\r\n  // check if the configuration has filterFields\r\n  if (config.filterFields) {\r\n    for (let field of config.filterFields) {\r\n      switch (field.type) {\r\n        case \"header\":\r\n          {\r\n            let value = req.headers[field.key];\r\n            if (!value) return { error: `No ${field.key} specified` };\r\n            let f = {};\r\n            if (field.key == \"company_id\") value = ObjectID(value);\r\n            f[field.column] = value;\r\n\r\n            // add filter\r\n            filter[\"$and\"].push(f);\r\n          }\r\n          break;\r\n        case \"filter\":\r\n          {\r\n            // add filter\r\n            filter[\"$and\"].push(eval(field.filter));\r\n          }\r\n          break;\r\n        case \"token\":\r\n          {\r\n            if (res.locals.token[field.key]) {\r\n              // add filter\r\n              let f = {};\r\n              f[field.column] = res.locals.token[field.key];\r\n              filter[\"$and\"].push(f);\r\n            }\r\n          }\r\n          break;\r\n        case \"ObjectID\":\r\n          {\r\n            if (data[field.column])\r\n              data[field.column] = ObjectID(data[field.column]);\r\n          }\r\n          break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // process the projection\r\n  let projection = {};\r\n  // include columns\r\n  if (data._projection) {\r\n    try {\r\n      let columns = data._projection.split(\",\");\r\n      for (let column of columns) {\r\n        column = column.trim();\r\n        projection[column] = 1;\r\n      }\r\n    } catch {}\r\n  }\r\n  if (data._projection_ne) {\r\n    try {\r\n      let columns = data._projection_ne.split(\",\");\r\n      for (let column of columns) {\r\n        column = column.trim();\r\n        projection[column] = 0;\r\n      }\r\n    } catch {}\r\n  }\r\n\r\n  for (let key of Object.keys(data)) {\r\n    if (key === \"page\") continue;\r\n    else if (key === \"size\") continue;\r\n    else if (key === \"_export\") continue;\r\n    else if (key === \"_aggregation\") continue;\r\n    else if (key === \"_sort\") continue;\r\n    else if (key === \"_sort_desc\") continue;\r\n    else if (key === \"_projection\") continue;\r\n    // _id gets ObjectId wrapper\r\n    else if (key === \"_id\" && data[key])\r\n      filter.$and.push({ _id: ObjectID(data[key]) });\r\n    // search\r\n    else if (key === \"_search\") {\r\n      if (data[key]) {\r\n        filter.$and.push({\r\n          $text: {\r\n            $search: data[key]\r\n          }\r\n        });\r\n        projection = { ...projection, score: { $meta: \"textScore\" } };\r\n        sort = { score: { $meta: \"textScore\" } };\r\n      }\r\n    }\r\n\r\n    // range\r\n    else if (key.endsWith(\"_date_gte\") || key.endsWith(\"_created_gte\")) {\r\n      let f = {};\r\n      f[key.replace(\"_gte\", \"\")] = { $gte: moment(data[key]).toDate() };\r\n      filter.$and.push(f);\r\n    } else if (key.endsWith(\"_date_gt\") || key.endsWith(\"_created_gt\")) {\r\n      let f = {};\r\n      f[key.replace(\"_gt\", \"\")] = { $gt: moment(data[key]).toDate() };\r\n      filter.$and.push(f);\r\n    } else if (key.endsWith(\"_date_lte\") || key.endsWith(\"_created_lte\")) {\r\n      let f = {};\r\n      f[key.replace(\"_lte\", \"\")] = { $lte: moment(data[key]).toDate() };\r\n      filter.$and.push(f);\r\n    } else if (key.endsWith(\"_date_lt\") || key.endsWith(\"_created_lt\")) {\r\n      let f = {};\r\n      f[key.replace(\"_lt\", \"\")] = { $lt: moment(data[key]).toDate() };\r\n      filter.$and.push(f);\r\n    }\r\n    // expression\r\n    else if (key.endsWith(\"$\")) {\r\n      let f = {};\r\n      f[key.substring(0, key.length - 1)] = eval(data[key]);\r\n      filter.$and.push(f);\r\n    }\r\n    // otherwise, string filter\r\n    else {\r\n      // if it is array make an or filter\r\n      if (Array.isArray(data[key])) {\r\n        let or = { $or: [] };\r\n        for (let v of data[key]) {\r\n          let f = {};\r\n          f[key] = v;\r\n          or.$or.push(f);\r\n        }\r\n        filter.$and.push(or);\r\n      } else if (data[key]) {\r\n        let f = {};\r\n        if (typeof data[key] == \"string\") {\r\n          f[key] = new RegExp(escapeRegExp(data[key]), \"ig\");\r\n        } else {\r\n          f[key] = data[key];\r\n        }\r\n        filter.$and.push(f);\r\n      }\r\n    }\r\n  }\r\n\r\n  // if $and is empty then remove\r\n  if (filter.$and.length == 0) delete filter.$and;\r\n\r\n  // retrieve data service\r\n  let ds = res.locals.ds;\r\n  if (!ds) return \"No data service instantiated\";\r\n\r\n  // connect to database\r\n  await ds.connect();\r\n\r\n  // query to the collection\r\n  let result = [];\r\n  let total = 0;\r\n  if(Object.keys(projection).length > 0) {\r\n    obj.ensureExists(config, \"aggregate\", []);\r\n    config.aggregate.push({$addFields:projection})\r\n  }\r\n  result = await ds.find(collection, {\r\n    query: filter,\r\n    aggregate: config.aggregate,\r\n    sort,\r\n    size,\r\n    skip: (page - 1) * size,\r\n    projection\r\n  });\r\n  total = await ds.count(collection, filter);\r\n\r\n  // remove fields\r\n  if (config.excludeFields) {\r\n    for (let row of result) {\r\n      for (let fields of config.excludeFields) {\r\n        if (row[fields]) delete row[fields];\r\n      }\r\n    }\r\n  }\r\n\r\n  // return result\r\n  return {\r\n    page: page,\r\n    size: result.length,\r\n    total: total,\r\n    filter: filter,\r\n    sort: sort,\r\n    projection: projection,\r\n    params: data,\r\n    websvc: res.locals.websvcurl,\r\n    data: result\r\n  };\r\n}\r\n\r\nrun();\r\n"
}

/* 11 createdAt:1970. 1. 1. 오전 1:00:00*/
{
	"_id" : "000000000000000000000040",
	"description" : "Upload binary contents to mongodb",
	"name" : "MongoDB Upload"
}